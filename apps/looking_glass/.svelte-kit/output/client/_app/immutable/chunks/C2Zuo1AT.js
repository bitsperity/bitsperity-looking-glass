import{e as dt}from"./CXH2uRM3.js";function ht(){const r=arguments[0];for(let t=1,e=arguments.length;t<e;t++)if(arguments[t])for(const i in arguments[t])r[i]=arguments[t][i];return r}let b=ht;typeof Object.assign=="function"&&(b=Object.assign);function x(r,t,e,i){const n=r._nodes.get(t);let o=null;return n&&(i==="mixed"?o=n.out&&n.out[e]||n.undirected&&n.undirected[e]:i==="directed"?o=n.out&&n.out[e]:o=n.undirected&&n.undirected[e]),o}function $(r){return typeof r=="object"&&r!==null}function J(r){let t;for(t in r)return!1;return!0}function _(r,t,e){Object.defineProperty(r,t,{enumerable:!1,configurable:!1,writable:!0,value:e})}function D(r,t,e){const i={enumerable:!0,configurable:!0};typeof e=="function"?i.get=e:(i.value=e,i.writable=!1),Object.defineProperty(r,t,i)}function R(r){return!(!$(r)||r.attributes&&!Array.isArray(r.attributes))}function ct(){let r=Math.floor(Math.random()*256)&255;return()=>r++}function v(){const r=arguments;let t=null,e=-1;return{[Symbol.iterator](){return this},next(){let i=null;do{if(t===null){if(e++,e>=r.length)return{done:!0};t=r[e][Symbol.iterator]()}if(i=t.next(),i.done){t=null;continue}break}while(!0);return i}}}function U(){return{[Symbol.iterator](){return this},next(){return{done:!0}}}}class T extends Error{constructor(t){super(),this.name="GraphError",this.message=t}}class l extends T{constructor(t){super(t),this.name="InvalidArgumentsGraphError",typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,l.prototype.constructor)}}class f extends T{constructor(t){super(t),this.name="NotFoundGraphError",typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,f.prototype.constructor)}}class g extends T{constructor(t){super(t),this.name="UsageGraphError",typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,g.prototype.constructor)}}function V(r,t){this.key=r,this.attributes=t,this.clear()}V.prototype.clear=function(){this.inDegree=0,this.outDegree=0,this.undirectedDegree=0,this.undirectedLoops=0,this.directedLoops=0,this.in={},this.out={},this.undirected={}};function q(r,t){this.key=r,this.attributes=t,this.clear()}q.prototype.clear=function(){this.inDegree=0,this.outDegree=0,this.directedLoops=0,this.in={},this.out={}};function Q(r,t){this.key=r,this.attributes=t,this.clear()}Q.prototype.clear=function(){this.undirectedDegree=0,this.undirectedLoops=0,this.undirected={}};function L(r,t,e,i,n){this.key=t,this.attributes=n,this.undirected=r,this.source=e,this.target=i}L.prototype.attach=function(){let r="out",t="in";this.undirected&&(r=t="undirected");const e=this.source.key,i=this.target.key;this.source[r][i]=this,!(this.undirected&&e===i)&&(this.target[t][e]=this)};L.prototype.attachMulti=function(){let r="out",t="in";const e=this.source.key,i=this.target.key;this.undirected&&(r=t="undirected");const n=this.source[r],o=n[i];if(typeof o>"u"){n[i]=this,this.undirected&&e===i||(this.target[t][e]=this);return}o.previous=this,this.next=o,n[i]=this,this.target[t][e]=this};L.prototype.detach=function(){const r=this.source.key,t=this.target.key;let e="out",i="in";this.undirected&&(e=i="undirected"),delete this.source[e][t],delete this.target[i][r]};L.prototype.detachMulti=function(){const r=this.source.key,t=this.target.key;let e="out",i="in";this.undirected&&(e=i="undirected"),this.previous===void 0?this.next===void 0?(delete this.source[e][t],delete this.target[i][r]):(this.next.previous=void 0,this.source[e][t]=this.next,this.target[i][r]=this.next):(this.previous.next=this.next,this.next!==void 0&&(this.next.previous=this.previous))};const X=0,Z=1,ft=2,tt=3;function N(r,t,e,i,n,o,s){let a,d,u,c;if(i=""+i,e===X){if(a=r._nodes.get(i),!a)throw new f(`Graph.${t}: could not find the "${i}" node in the graph.`);u=n,c=o}else if(e===tt){if(n=""+n,d=r._edges.get(n),!d)throw new f(`Graph.${t}: could not find the "${n}" edge in the graph.`);const h=d.source.key,p=d.target.key;if(i===h)a=d.target;else if(i===p)a=d.source;else throw new f(`Graph.${t}: the "${i}" node is not attached to the "${n}" edge (${h}, ${p}).`);u=o,c=s}else{if(d=r._edges.get(i),!d)throw new f(`Graph.${t}: could not find the "${i}" edge in the graph.`);e===Z?a=d.source:a=d.target,u=n,c=o}return[a,u,c]}function pt(r,t,e){r.prototype[t]=function(i,n,o){const[s,a]=N(this,t,e,i,n,o);return s.attributes[a]}}function lt(r,t,e){r.prototype[t]=function(i,n){const[o]=N(this,t,e,i,n);return o.attributes}}function gt(r,t,e){r.prototype[t]=function(i,n,o){const[s,a]=N(this,t,e,i,n,o);return s.attributes.hasOwnProperty(a)}}function yt(r,t,e){r.prototype[t]=function(i,n,o,s){const[a,d,u]=N(this,t,e,i,n,o,s);return a.attributes[d]=u,this.emit("nodeAttributesUpdated",{key:a.key,type:"set",attributes:a.attributes,name:d}),this}}function wt(r,t,e){r.prototype[t]=function(i,n,o,s){const[a,d,u]=N(this,t,e,i,n,o,s);if(typeof u!="function")throw new l(`Graph.${t}: updater should be a function.`);const c=a.attributes,h=u(c[d]);return c[d]=h,this.emit("nodeAttributesUpdated",{key:a.key,type:"set",attributes:a.attributes,name:d}),this}}function mt(r,t,e){r.prototype[t]=function(i,n,o){const[s,a]=N(this,t,e,i,n,o);return delete s.attributes[a],this.emit("nodeAttributesUpdated",{key:s.key,type:"remove",attributes:s.attributes,name:a}),this}}function bt(r,t,e){r.prototype[t]=function(i,n,o){const[s,a]=N(this,t,e,i,n,o);if(!$(a))throw new l(`Graph.${t}: provided attributes are not a plain object.`);return s.attributes=a,this.emit("nodeAttributesUpdated",{key:s.key,type:"replace",attributes:s.attributes}),this}}function $t(r,t,e){r.prototype[t]=function(i,n,o){const[s,a]=N(this,t,e,i,n,o);if(!$(a))throw new l(`Graph.${t}: provided attributes are not a plain object.`);return b(s.attributes,a),this.emit("nodeAttributesUpdated",{key:s.key,type:"merge",attributes:s.attributes,data:a}),this}}function Gt(r,t,e){r.prototype[t]=function(i,n,o){const[s,a]=N(this,t,e,i,n,o);if(typeof a!="function")throw new l(`Graph.${t}: provided updater is not a function.`);return s.attributes=a(s.attributes),this.emit("nodeAttributesUpdated",{key:s.key,type:"update",attributes:s.attributes}),this}}const Et=[{name:r=>`get${r}Attribute`,attacher:pt},{name:r=>`get${r}Attributes`,attacher:lt},{name:r=>`has${r}Attribute`,attacher:gt},{name:r=>`set${r}Attribute`,attacher:yt},{name:r=>`update${r}Attribute`,attacher:wt},{name:r=>`remove${r}Attribute`,attacher:mt},{name:r=>`replace${r}Attributes`,attacher:bt},{name:r=>`merge${r}Attributes`,attacher:$t},{name:r=>`update${r}Attributes`,attacher:Gt}];function kt(r){Et.forEach(function({name:t,attacher:e}){e(r,t("Node"),X),e(r,t("Source"),Z),e(r,t("Target"),ft),e(r,t("Opposite"),tt)})}function _t(r,t,e){r.prototype[t]=function(i,n){let o;if(this.type!=="mixed"&&e!=="mixed"&&e!==this.type)throw new g(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new g(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const s=""+i,a=""+n;if(n=arguments[2],o=x(this,s,a,e),!o)throw new f(`Graph.${t}: could not find an edge for the given path ("${s}" - "${a}").`)}else{if(e!=="mixed")throw new g(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(i=""+i,o=this._edges.get(i),!o)throw new f(`Graph.${t}: could not find the "${i}" edge in the graph.`)}return o.attributes[n]}}function xt(r,t,e){r.prototype[t]=function(i){let n;if(this.type!=="mixed"&&e!=="mixed"&&e!==this.type)throw new g(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>1){if(this.multi)throw new g(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const o=""+i,s=""+arguments[1];if(n=x(this,o,s,e),!n)throw new f(`Graph.${t}: could not find an edge for the given path ("${o}" - "${s}").`)}else{if(e!=="mixed")throw new g(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(i=""+i,n=this._edges.get(i),!n)throw new f(`Graph.${t}: could not find the "${i}" edge in the graph.`)}return n.attributes}}function Dt(r,t,e){r.prototype[t]=function(i,n){let o;if(this.type!=="mixed"&&e!=="mixed"&&e!==this.type)throw new g(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new g(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const s=""+i,a=""+n;if(n=arguments[2],o=x(this,s,a,e),!o)throw new f(`Graph.${t}: could not find an edge for the given path ("${s}" - "${a}").`)}else{if(e!=="mixed")throw new g(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(i=""+i,o=this._edges.get(i),!o)throw new f(`Graph.${t}: could not find the "${i}" edge in the graph.`)}return o.attributes.hasOwnProperty(n)}}function At(r,t,e){r.prototype[t]=function(i,n,o){let s;if(this.type!=="mixed"&&e!=="mixed"&&e!==this.type)throw new g(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>3){if(this.multi)throw new g(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const a=""+i,d=""+n;if(n=arguments[2],o=arguments[3],s=x(this,a,d,e),!s)throw new f(`Graph.${t}: could not find an edge for the given path ("${a}" - "${d}").`)}else{if(e!=="mixed")throw new g(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(i=""+i,s=this._edges.get(i),!s)throw new f(`Graph.${t}: could not find the "${i}" edge in the graph.`)}return s.attributes[n]=o,this.emit("edgeAttributesUpdated",{key:s.key,type:"set",attributes:s.attributes,name:n}),this}}function vt(r,t,e){r.prototype[t]=function(i,n,o){let s;if(this.type!=="mixed"&&e!=="mixed"&&e!==this.type)throw new g(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>3){if(this.multi)throw new g(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const a=""+i,d=""+n;if(n=arguments[2],o=arguments[3],s=x(this,a,d,e),!s)throw new f(`Graph.${t}: could not find an edge for the given path ("${a}" - "${d}").`)}else{if(e!=="mixed")throw new g(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(i=""+i,s=this._edges.get(i),!s)throw new f(`Graph.${t}: could not find the "${i}" edge in the graph.`)}if(typeof o!="function")throw new l(`Graph.${t}: updater should be a function.`);return s.attributes[n]=o(s.attributes[n]),this.emit("edgeAttributesUpdated",{key:s.key,type:"set",attributes:s.attributes,name:n}),this}}function Nt(r,t,e){r.prototype[t]=function(i,n){let o;if(this.type!=="mixed"&&e!=="mixed"&&e!==this.type)throw new g(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new g(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const s=""+i,a=""+n;if(n=arguments[2],o=x(this,s,a,e),!o)throw new f(`Graph.${t}: could not find an edge for the given path ("${s}" - "${a}").`)}else{if(e!=="mixed")throw new g(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(i=""+i,o=this._edges.get(i),!o)throw new f(`Graph.${t}: could not find the "${i}" edge in the graph.`)}return delete o.attributes[n],this.emit("edgeAttributesUpdated",{key:o.key,type:"remove",attributes:o.attributes,name:n}),this}}function St(r,t,e){r.prototype[t]=function(i,n){let o;if(this.type!=="mixed"&&e!=="mixed"&&e!==this.type)throw new g(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new g(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const s=""+i,a=""+n;if(n=arguments[2],o=x(this,s,a,e),!o)throw new f(`Graph.${t}: could not find an edge for the given path ("${s}" - "${a}").`)}else{if(e!=="mixed")throw new g(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(i=""+i,o=this._edges.get(i),!o)throw new f(`Graph.${t}: could not find the "${i}" edge in the graph.`)}if(!$(n))throw new l(`Graph.${t}: provided attributes are not a plain object.`);return o.attributes=n,this.emit("edgeAttributesUpdated",{key:o.key,type:"replace",attributes:o.attributes}),this}}function Ut(r,t,e){r.prototype[t]=function(i,n){let o;if(this.type!=="mixed"&&e!=="mixed"&&e!==this.type)throw new g(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new g(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const s=""+i,a=""+n;if(n=arguments[2],o=x(this,s,a,e),!o)throw new f(`Graph.${t}: could not find an edge for the given path ("${s}" - "${a}").`)}else{if(e!=="mixed")throw new g(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(i=""+i,o=this._edges.get(i),!o)throw new f(`Graph.${t}: could not find the "${i}" edge in the graph.`)}if(!$(n))throw new l(`Graph.${t}: provided attributes are not a plain object.`);return b(o.attributes,n),this.emit("edgeAttributesUpdated",{key:o.key,type:"merge",attributes:o.attributes,data:n}),this}}function Lt(r,t,e){r.prototype[t]=function(i,n){let o;if(this.type!=="mixed"&&e!=="mixed"&&e!==this.type)throw new g(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new g(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const s=""+i,a=""+n;if(n=arguments[2],o=x(this,s,a,e),!o)throw new f(`Graph.${t}: could not find an edge for the given path ("${s}" - "${a}").`)}else{if(e!=="mixed")throw new g(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(i=""+i,o=this._edges.get(i),!o)throw new f(`Graph.${t}: could not find the "${i}" edge in the graph.`)}if(typeof n!="function")throw new l(`Graph.${t}: provided updater is not a function.`);return o.attributes=n(o.attributes),this.emit("edgeAttributesUpdated",{key:o.key,type:"update",attributes:o.attributes}),this}}const Mt=[{name:r=>`get${r}Attribute`,attacher:_t},{name:r=>`get${r}Attributes`,attacher:xt},{name:r=>`has${r}Attribute`,attacher:Dt},{name:r=>`set${r}Attribute`,attacher:At},{name:r=>`update${r}Attribute`,attacher:vt},{name:r=>`remove${r}Attribute`,attacher:Nt},{name:r=>`replace${r}Attributes`,attacher:St},{name:r=>`merge${r}Attributes`,attacher:Ut},{name:r=>`update${r}Attributes`,attacher:Lt}];function Ct(r){Mt.forEach(function({name:t,attacher:e}){e(r,t("Edge"),"mixed"),e(r,t("DirectedEdge"),"directed"),e(r,t("UndirectedEdge"),"undirected")})}const zt=[{name:"edges",type:"mixed"},{name:"inEdges",type:"directed",direction:"in"},{name:"outEdges",type:"directed",direction:"out"},{name:"inboundEdges",type:"mixed",direction:"in"},{name:"outboundEdges",type:"mixed",direction:"out"},{name:"directedEdges",type:"directed"},{name:"undirectedEdges",type:"undirected"}];function It(r,t,e,i){let n=!1;for(const o in t){if(o===i)continue;const s=t[o];if(n=e(s.key,s.attributes,s.source.key,s.target.key,s.source.attributes,s.target.attributes,s.undirected),r&&n)return s.key}}function jt(r,t,e,i){let n,o,s,a=!1;for(const d in t)if(d!==i){n=t[d];do{if(o=n.source,s=n.target,a=e(n.key,n.attributes,o.key,s.key,o.attributes,s.attributes,n.undirected),r&&a)return n.key;n=n.next}while(n!==void 0)}}function W(r,t){const e=Object.keys(r),i=e.length;let n,o=0;return{[Symbol.iterator](){return this},next(){do if(n)n=n.next;else{if(o>=i)return{done:!0};const s=e[o++];if(s===t){n=void 0;continue}n=r[s]}while(!n);return{done:!1,value:{edge:n.key,attributes:n.attributes,source:n.source.key,target:n.target.key,sourceAttributes:n.source.attributes,targetAttributes:n.target.attributes,undirected:n.undirected}}}}}function Ot(r,t,e,i){const n=t[e];if(!n)return;const o=n.source,s=n.target;if(i(n.key,n.attributes,o.key,s.key,o.attributes,s.attributes,n.undirected)&&r)return n.key}function Wt(r,t,e,i){let n=t[e];if(!n)return;let o=!1;do{if(o=i(n.key,n.attributes,n.source.key,n.target.key,n.source.attributes,n.target.attributes,n.undirected),r&&o)return n.key;n=n.next}while(n!==void 0)}function K(r,t){let e=r[t];if(e.next!==void 0)return{[Symbol.iterator](){return this},next(){if(!e)return{done:!0};const n={edge:e.key,attributes:e.attributes,source:e.source.key,target:e.target.key,sourceAttributes:e.source.attributes,targetAttributes:e.target.attributes,undirected:e.undirected};return e=e.next,{done:!1,value:n}}};let i=!1;return{[Symbol.iterator](){return this},next(){return i===!0?{done:!0}:(i=!0,{done:!1,value:{edge:e.key,attributes:e.attributes,source:e.source.key,target:e.target.key,sourceAttributes:e.source.attributes,targetAttributes:e.target.attributes,undirected:e.undirected}})}}}function Kt(r,t){if(r.size===0)return[];if(t==="mixed"||t===r.type)return Array.from(r._edges.keys());const e=t==="undirected"?r.undirectedSize:r.directedSize,i=new Array(e),n=t==="undirected",o=r._edges.values();let s=0,a,d;for(;a=o.next(),a.done!==!0;)d=a.value,d.undirected===n&&(i[s++]=d.key);return i}function et(r,t,e,i){if(t.size===0)return;const n=e!=="mixed"&&e!==t.type,o=e==="undirected";let s,a,d=!1;const u=t._edges.values();for(;s=u.next(),s.done!==!0;){if(a=s.value,n&&a.undirected!==o)continue;const{key:c,attributes:h,source:p,target:y}=a;if(d=i(c,h,p.key,y.key,p.attributes,y.attributes,a.undirected),r&&d)return c}}function Tt(r,t){if(r.size===0)return U();const e=t!=="mixed"&&t!==r.type,i=t==="undirected",n=r._edges.values();return{[Symbol.iterator](){return this},next(){let o,s;for(;;){if(o=n.next(),o.done)return o;if(s=o.value,!(e&&s.undirected!==i))break}return{value:{edge:s.key,attributes:s.attributes,source:s.source.key,target:s.target.key,sourceAttributes:s.source.attributes,targetAttributes:s.target.attributes,undirected:s.undirected},done:!1}}}}function P(r,t,e,i,n,o){const s=t?jt:It;let a;if(e!=="undirected"&&(i!=="out"&&(a=s(r,n.in,o),r&&a)||i!=="in"&&(a=s(r,n.out,o,i?void 0:n.key),r&&a))||e!=="directed"&&(a=s(r,n.undirected,o),r&&a))return a}function Pt(r,t,e,i){const n=[];return P(!1,r,t,e,i,function(o){n.push(o)}),n}function Ft(r,t,e){let i=U();return r!=="undirected"&&(t!=="out"&&typeof e.in<"u"&&(i=v(i,W(e.in))),t!=="in"&&typeof e.out<"u"&&(i=v(i,W(e.out,t?void 0:e.key)))),r!=="directed"&&typeof e.undirected<"u"&&(i=v(i,W(e.undirected))),i}function F(r,t,e,i,n,o,s){const a=e?Wt:Ot;let d;if(t!=="undirected"&&(typeof n.in<"u"&&i!=="out"&&(d=a(r,n.in,o,s),r&&d)||typeof n.out<"u"&&i!=="in"&&(i||n.key!==o)&&(d=a(r,n.out,o,s),r&&d))||t!=="directed"&&typeof n.undirected<"u"&&(d=a(r,n.undirected,o,s),r&&d))return d}function Bt(r,t,e,i,n){const o=[];return F(!1,r,t,e,i,n,function(s){o.push(s)}),o}function Rt(r,t,e,i){let n=U();return r!=="undirected"&&(typeof e.in<"u"&&t!=="out"&&i in e.in&&(n=v(n,K(e.in,i))),typeof e.out<"u"&&t!=="in"&&i in e.out&&(t||e.key!==i)&&(n=v(n,K(e.out,i)))),r!=="directed"&&typeof e.undirected<"u"&&i in e.undirected&&(n=v(n,K(e.undirected,i))),n}function Yt(r,t){const{name:e,type:i,direction:n}=t;r.prototype[e]=function(o,s){if(i!=="mixed"&&this.type!=="mixed"&&i!==this.type)return[];if(!arguments.length)return Kt(this,i);if(arguments.length===1){o=""+o;const a=this._nodes.get(o);if(typeof a>"u")throw new f(`Graph.${e}: could not find the "${o}" node in the graph.`);return Pt(this.multi,i==="mixed"?this.type:i,n,a)}if(arguments.length===2){o=""+o,s=""+s;const a=this._nodes.get(o);if(!a)throw new f(`Graph.${e}:  could not find the "${o}" source node in the graph.`);if(!this._nodes.has(s))throw new f(`Graph.${e}:  could not find the "${s}" target node in the graph.`);return Bt(i,this.multi,n,a,s)}throw new l(`Graph.${e}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`)}}function Ht(r,t){const{name:e,type:i,direction:n}=t,o="forEach"+e[0].toUpperCase()+e.slice(1,-1);r.prototype[o]=function(u,c,h){if(!(i!=="mixed"&&this.type!=="mixed"&&i!==this.type)){if(arguments.length===1)return h=u,et(!1,this,i,h);if(arguments.length===2){u=""+u,h=c;const p=this._nodes.get(u);if(typeof p>"u")throw new f(`Graph.${o}: could not find the "${u}" node in the graph.`);return P(!1,this.multi,i==="mixed"?this.type:i,n,p,h)}if(arguments.length===3){u=""+u,c=""+c;const p=this._nodes.get(u);if(!p)throw new f(`Graph.${o}:  could not find the "${u}" source node in the graph.`);if(!this._nodes.has(c))throw new f(`Graph.${o}:  could not find the "${c}" target node in the graph.`);return F(!1,i,this.multi,n,p,c,h)}throw new l(`Graph.${o}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`)}};const s="map"+e[0].toUpperCase()+e.slice(1);r.prototype[s]=function(){const u=Array.prototype.slice.call(arguments),c=u.pop();let h;if(u.length===0){let p=0;i!=="directed"&&(p+=this.undirectedSize),i!=="undirected"&&(p+=this.directedSize),h=new Array(p);let y=0;u.push((m,E,G,k,A,C,ut)=>{h[y++]=c(m,E,G,k,A,C,ut)})}else h=[],u.push((p,y,m,E,G,k,A)=>{h.push(c(p,y,m,E,G,k,A))});return this[o].apply(this,u),h};const a="filter"+e[0].toUpperCase()+e.slice(1);r.prototype[a]=function(){const u=Array.prototype.slice.call(arguments),c=u.pop(),h=[];return u.push((p,y,m,E,G,k,A)=>{c(p,y,m,E,G,k,A)&&h.push(p)}),this[o].apply(this,u),h};const d="reduce"+e[0].toUpperCase()+e.slice(1);r.prototype[d]=function(){let u=Array.prototype.slice.call(arguments);if(u.length<2||u.length>4)throw new l(`Graph.${d}: invalid number of arguments (expecting 2, 3 or 4 and got ${u.length}).`);if(typeof u[u.length-1]=="function"&&typeof u[u.length-2]!="function")throw new l(`Graph.${d}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`);let c,h;u.length===2?(c=u[0],h=u[1],u=[]):u.length===3?(c=u[1],h=u[2],u=[u[0]]):u.length===4&&(c=u[2],h=u[3],u=[u[0],u[1]]);let p=h;return u.push((y,m,E,G,k,A,C)=>{p=c(p,y,m,E,G,k,A,C)}),this[o].apply(this,u),p}}function Jt(r,t){const{name:e,type:i,direction:n}=t,o="find"+e[0].toUpperCase()+e.slice(1,-1);r.prototype[o]=function(d,u,c){if(i!=="mixed"&&this.type!=="mixed"&&i!==this.type)return!1;if(arguments.length===1)return c=d,et(!0,this,i,c);if(arguments.length===2){d=""+d,c=u;const h=this._nodes.get(d);if(typeof h>"u")throw new f(`Graph.${o}: could not find the "${d}" node in the graph.`);return P(!0,this.multi,i==="mixed"?this.type:i,n,h,c)}if(arguments.length===3){d=""+d,u=""+u;const h=this._nodes.get(d);if(!h)throw new f(`Graph.${o}:  could not find the "${d}" source node in the graph.`);if(!this._nodes.has(u))throw new f(`Graph.${o}:  could not find the "${u}" target node in the graph.`);return F(!0,i,this.multi,n,h,u,c)}throw new l(`Graph.${o}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`)};const s="some"+e[0].toUpperCase()+e.slice(1,-1);r.prototype[s]=function(){const d=Array.prototype.slice.call(arguments),u=d.pop();return d.push((h,p,y,m,E,G,k)=>u(h,p,y,m,E,G,k)),!!this[o].apply(this,d)};const a="every"+e[0].toUpperCase()+e.slice(1,-1);r.prototype[a]=function(){const d=Array.prototype.slice.call(arguments),u=d.pop();return d.push((h,p,y,m,E,G,k)=>!u(h,p,y,m,E,G,k)),!this[o].apply(this,d)}}function Vt(r,t){const{name:e,type:i,direction:n}=t,o=e.slice(0,-1)+"Entries";r.prototype[o]=function(s,a){if(i!=="mixed"&&this.type!=="mixed"&&i!==this.type)return U();if(!arguments.length)return Tt(this,i);if(arguments.length===1){s=""+s;const d=this._nodes.get(s);if(!d)throw new f(`Graph.${o}: could not find the "${s}" node in the graph.`);return Ft(i,n,d)}if(arguments.length===2){s=""+s,a=""+a;const d=this._nodes.get(s);if(!d)throw new f(`Graph.${o}:  could not find the "${s}" source node in the graph.`);if(!this._nodes.has(a))throw new f(`Graph.${o}:  could not find the "${a}" target node in the graph.`);return Rt(i,n,d,a)}throw new l(`Graph.${o}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`)}}function qt(r){zt.forEach(t=>{Yt(r,t),Ht(r,t),Jt(r,t),Vt(r,t)})}const Qt=[{name:"neighbors",type:"mixed"},{name:"inNeighbors",type:"directed",direction:"in"},{name:"outNeighbors",type:"directed",direction:"out"},{name:"inboundNeighbors",type:"mixed",direction:"in"},{name:"outboundNeighbors",type:"mixed",direction:"out"},{name:"directedNeighbors",type:"directed"},{name:"undirectedNeighbors",type:"undirected"}];function O(){this.A=null,this.B=null}O.prototype.wrap=function(r){this.A===null?this.A=r:this.B===null&&(this.B=r)};O.prototype.has=function(r){return this.A!==null&&r in this.A||this.B!==null&&r in this.B};function z(r,t,e,i,n){for(const o in i){const s=i[o],a=s.source,d=s.target,u=a===e?d:a;if(t&&t.has(u.key))continue;const c=n(u.key,u.attributes);if(r&&c)return u.key}}function B(r,t,e,i,n){if(t!=="mixed"){if(t==="undirected")return z(r,null,i,i.undirected,n);if(typeof e=="string")return z(r,null,i,i[e],n)}const o=new O;let s;if(t!=="undirected"){if(e!=="out"){if(s=z(r,null,i,i.in,n),r&&s)return s;o.wrap(i.in)}if(e!=="in"){if(s=z(r,o,i,i.out,n),r&&s)return s;o.wrap(i.out)}}if(t!=="directed"&&(s=z(r,o,i,i.undirected,n),r&&s))return s}function Xt(r,t,e){if(r!=="mixed"){if(r==="undirected")return Object.keys(e.undirected);if(typeof t=="string")return Object.keys(e[t])}const i=[];return B(!1,r,t,e,function(n){i.push(n)}),i}function I(r,t,e){const i=Object.keys(e),n=i.length;let o=0;return{[Symbol.iterator](){return this},next(){let s=null;do{if(o>=n)return r&&r.wrap(e),{done:!0};const a=e[i[o++]],d=a.source,u=a.target;if(s=d===t?u:d,r&&r.has(s.key)){s=null;continue}}while(s===null);return{done:!1,value:{neighbor:s.key,attributes:s.attributes}}}}}function Zt(r,t,e){if(r!=="mixed"){if(r==="undirected")return I(null,e,e.undirected);if(typeof t=="string")return I(null,e,e[t])}let i=U();const n=new O;return r!=="undirected"&&(t!=="out"&&(i=v(i,I(n,e,e.in))),t!=="in"&&(i=v(i,I(n,e,e.out)))),r!=="directed"&&(i=v(i,I(n,e,e.undirected))),i}function te(r,t){const{name:e,type:i,direction:n}=t;r.prototype[e]=function(o){if(i!=="mixed"&&this.type!=="mixed"&&i!==this.type)return[];o=""+o;const s=this._nodes.get(o);if(typeof s>"u")throw new f(`Graph.${e}: could not find the "${o}" node in the graph.`);return Xt(i==="mixed"?this.type:i,n,s)}}function ee(r,t){const{name:e,type:i,direction:n}=t,o="forEach"+e[0].toUpperCase()+e.slice(1,-1);r.prototype[o]=function(u,c){if(i!=="mixed"&&this.type!=="mixed"&&i!==this.type)return;u=""+u;const h=this._nodes.get(u);if(typeof h>"u")throw new f(`Graph.${o}: could not find the "${u}" node in the graph.`);B(!1,i==="mixed"?this.type:i,n,h,c)};const s="map"+e[0].toUpperCase()+e.slice(1);r.prototype[s]=function(u,c){const h=[];return this[o](u,(p,y)=>{h.push(c(p,y))}),h};const a="filter"+e[0].toUpperCase()+e.slice(1);r.prototype[a]=function(u,c){const h=[];return this[o](u,(p,y)=>{c(p,y)&&h.push(p)}),h};const d="reduce"+e[0].toUpperCase()+e.slice(1);r.prototype[d]=function(u,c,h){if(arguments.length<3)throw new l(`Graph.${d}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`);let p=h;return this[o](u,(y,m)=>{p=c(p,y,m)}),p}}function ie(r,t){const{name:e,type:i,direction:n}=t,o=e[0].toUpperCase()+e.slice(1,-1),s="find"+o;r.prototype[s]=function(u,c){if(i!=="mixed"&&this.type!=="mixed"&&i!==this.type)return;u=""+u;const h=this._nodes.get(u);if(typeof h>"u")throw new f(`Graph.${s}: could not find the "${u}" node in the graph.`);return B(!0,i==="mixed"?this.type:i,n,h,c)};const a="some"+o;r.prototype[a]=function(u,c){return!!this[s](u,c)};const d="every"+o;r.prototype[d]=function(u,c){return!this[s](u,(p,y)=>!c(p,y))}}function ne(r,t){const{name:e,type:i,direction:n}=t,o=e.slice(0,-1)+"Entries";r.prototype[o]=function(s){if(i!=="mixed"&&this.type!=="mixed"&&i!==this.type)return U();s=""+s;const a=this._nodes.get(s);if(typeof a>"u")throw new f(`Graph.${o}: could not find the "${s}" node in the graph.`);return Zt(i==="mixed"?this.type:i,n,a)}}function re(r){Qt.forEach(t=>{te(r,t),ee(r,t),ie(r,t),ne(r,t)})}function j(r,t,e,i,n){const o=i._nodes.values(),s=i.type;let a,d,u,c,h,p;for(;a=o.next(),a.done!==!0;){let y=!1;if(d=a.value,s!=="undirected"){c=d.out;for(u in c){h=c[u];do p=h.target,y=!0,n(d.key,p.key,d.attributes,p.attributes,h.key,h.attributes,h.undirected),h=h.next;while(h)}}if(s!=="directed"){c=d.undirected;for(u in c)if(!(t&&d.key>u)){h=c[u];do p=h.target,p.key!==u&&(p=h.source),y=!0,n(d.key,p.key,d.attributes,p.attributes,h.key,h.attributes,h.undirected),h=h.next;while(h)}}e&&!y&&n(d.key,null,d.attributes,null,null,null,null)}}function oe(r,t){const e={key:r};return J(t.attributes)||(e.attributes=b({},t.attributes)),e}function se(r,t,e){const i={key:t,source:e.source.key,target:e.target.key};return J(e.attributes)||(i.attributes=b({},e.attributes)),r==="mixed"&&e.undirected&&(i.undirected=!0),i}function ae(r){if(!$(r))throw new l('Graph.import: invalid serialized node. A serialized node should be a plain object with at least a "key" property.');if(!("key"in r))throw new l("Graph.import: serialized node is missing its key.");if("attributes"in r&&(!$(r.attributes)||r.attributes===null))throw new l("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.")}function ue(r){if(!$(r))throw new l('Graph.import: invalid serialized edge. A serialized edge should be a plain object with at least a "source" & "target" property.');if(!("source"in r))throw new l("Graph.import: serialized edge is missing its source.");if(!("target"in r))throw new l("Graph.import: serialized edge is missing its target.");if("attributes"in r&&(!$(r.attributes)||r.attributes===null))throw new l("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.");if("undirected"in r&&typeof r.undirected!="boolean")throw new l("Graph.import: invalid undirectedness information. Undirected should be boolean or omitted.")}const de=ct(),he=new Set(["directed","undirected","mixed"]),Y=new Set(["domain","_events","_eventsCount","_maxListeners"]),ce=[{name:r=>`${r}Edge`,generateKey:!0},{name:r=>`${r}DirectedEdge`,generateKey:!0,type:"directed"},{name:r=>`${r}UndirectedEdge`,generateKey:!0,type:"undirected"},{name:r=>`${r}EdgeWithKey`},{name:r=>`${r}DirectedEdgeWithKey`,type:"directed"},{name:r=>`${r}UndirectedEdgeWithKey`,type:"undirected"}],fe={allowSelfLoops:!0,multi:!1,type:"mixed"};function pe(r,t,e){if(e&&!$(e))throw new l(`Graph.addNode: invalid attributes. Expecting an object but got "${e}"`);if(t=""+t,e=e||{},r._nodes.has(t))throw new g(`Graph.addNode: the "${t}" node already exist in the graph.`);const i=new r.NodeDataClass(t,e);return r._nodes.set(t,i),r.emit("nodeAdded",{key:t,attributes:e}),i}function H(r,t,e){const i=new r.NodeDataClass(t,e);return r._nodes.set(t,i),r.emit("nodeAdded",{key:t,attributes:e}),i}function it(r,t,e,i,n,o,s,a){if(!i&&r.type==="undirected")throw new g(`Graph.${t}: you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.`);if(i&&r.type==="directed")throw new g(`Graph.${t}: you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.`);if(a&&!$(a))throw new l(`Graph.${t}: invalid attributes. Expecting an object but got "${a}"`);if(o=""+o,s=""+s,a=a||{},!r.allowSelfLoops&&o===s)throw new g(`Graph.${t}: source & target are the same ("${o}"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`);const d=r._nodes.get(o),u=r._nodes.get(s);if(!d)throw new f(`Graph.${t}: source node "${o}" not found.`);if(!u)throw new f(`Graph.${t}: target node "${s}" not found.`);const c={key:null,undirected:i,source:o,target:s,attributes:a};if(e)n=r._edgeKeyGenerator();else if(n=""+n,r._edges.has(n))throw new g(`Graph.${t}: the "${n}" edge already exists in the graph.`);if(!r.multi&&(i?typeof d.undirected[s]<"u":typeof d.out[s]<"u"))throw new g(`Graph.${t}: an edge linking "${o}" to "${s}" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option.`);const h=new L(i,n,d,u,a);r._edges.set(n,h);const p=o===s;return i?(d.undirectedDegree++,u.undirectedDegree++,p&&(d.undirectedLoops++,r._undirectedSelfLoopCount++)):(d.outDegree++,u.inDegree++,p&&(d.directedLoops++,r._directedSelfLoopCount++)),r.multi?h.attachMulti():h.attach(),i?r._undirectedSize++:r._directedSize++,c.key=n,r.emit("edgeAdded",c),n}function le(r,t,e,i,n,o,s,a,d){if(!i&&r.type==="undirected")throw new g(`Graph.${t}: you cannot merge/update a directed edge to an undirected graph. Use the #.mergeEdge/#.updateEdge or #.addUndirectedEdge instead.`);if(i&&r.type==="directed")throw new g(`Graph.${t}: you cannot merge/update an undirected edge to a directed graph. Use the #.mergeEdge/#.updateEdge or #.addDirectedEdge instead.`);if(a){if(d){if(typeof a!="function")throw new l(`Graph.${t}: invalid updater function. Expecting a function but got "${a}"`)}else if(!$(a))throw new l(`Graph.${t}: invalid attributes. Expecting an object but got "${a}"`)}o=""+o,s=""+s;let u;if(d&&(u=a,a=void 0),!r.allowSelfLoops&&o===s)throw new g(`Graph.${t}: source & target are the same ("${o}"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`);let c=r._nodes.get(o),h=r._nodes.get(s),p,y;if(!e&&(p=r._edges.get(n),p)){if((p.source.key!==o||p.target.key!==s)&&(!i||p.source.key!==s||p.target.key!==o))throw new g(`Graph.${t}: inconsistency detected when attempting to merge the "${n}" edge with "${o}" source & "${s}" target vs. ("${p.source.key}", "${p.target.key}").`);y=p}if(!y&&!r.multi&&c&&(y=i?c.undirected[s]:c.out[s]),y){const A=[y.key,!1,!1,!1];if(d?!u:!a)return A;if(d){const C=y.attributes;y.attributes=u(C),r.emit("edgeAttributesUpdated",{type:"replace",key:y.key,attributes:y.attributes})}else b(y.attributes,a),r.emit("edgeAttributesUpdated",{type:"merge",key:y.key,attributes:y.attributes,data:a});return A}a=a||{},d&&u&&(a=u(a));const m={key:null,undirected:i,source:o,target:s,attributes:a};if(e)n=r._edgeKeyGenerator();else if(n=""+n,r._edges.has(n))throw new g(`Graph.${t}: the "${n}" edge already exists in the graph.`);let E=!1,G=!1;c||(c=H(r,o,{}),E=!0,o===s&&(h=c,G=!0)),h||(h=H(r,s,{}),G=!0),p=new L(i,n,c,h,a),r._edges.set(n,p);const k=o===s;return i?(c.undirectedDegree++,h.undirectedDegree++,k&&(c.undirectedLoops++,r._undirectedSelfLoopCount++)):(c.outDegree++,h.inDegree++,k&&(c.directedLoops++,r._directedSelfLoopCount++)),r.multi?p.attachMulti():p.attach(),i?r._undirectedSize++:r._directedSize++,m.key=n,r.emit("edgeAdded",m),[n,!0,E,G]}function S(r,t){r._edges.delete(t.key);const{source:e,target:i,attributes:n}=t,o=t.undirected,s=e===i;o?(e.undirectedDegree--,i.undirectedDegree--,s&&(e.undirectedLoops--,r._undirectedSelfLoopCount--)):(e.outDegree--,i.inDegree--,s&&(e.directedLoops--,r._directedSelfLoopCount--)),r.multi?t.detachMulti():t.detach(),o?r._undirectedSize--:r._directedSize--,r.emit("edgeDropped",{key:t.key,attributes:n,source:e.key,target:i.key,undirected:o})}class w extends dt.EventEmitter{constructor(t){if(super(),t=b({},fe,t),typeof t.multi!="boolean")throw new l(`Graph.constructor: invalid 'multi' option. Expecting a boolean but got "${t.multi}".`);if(!he.has(t.type))throw new l(`Graph.constructor: invalid 'type' option. Should be one of "mixed", "directed" or "undirected" but got "${t.type}".`);if(typeof t.allowSelfLoops!="boolean")throw new l(`Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got "${t.allowSelfLoops}".`);const e=t.type==="mixed"?V:t.type==="directed"?q:Q;_(this,"NodeDataClass",e);const i="geid_"+de()+"_";let n=0;const o=()=>{let s;do s=i+n++;while(this._edges.has(s));return s};_(this,"_attributes",{}),_(this,"_nodes",new Map),_(this,"_edges",new Map),_(this,"_directedSize",0),_(this,"_undirectedSize",0),_(this,"_directedSelfLoopCount",0),_(this,"_undirectedSelfLoopCount",0),_(this,"_edgeKeyGenerator",o),_(this,"_options",t),Y.forEach(s=>_(this,s,this[s])),D(this,"order",()=>this._nodes.size),D(this,"size",()=>this._edges.size),D(this,"directedSize",()=>this._directedSize),D(this,"undirectedSize",()=>this._undirectedSize),D(this,"selfLoopCount",()=>this._directedSelfLoopCount+this._undirectedSelfLoopCount),D(this,"directedSelfLoopCount",()=>this._directedSelfLoopCount),D(this,"undirectedSelfLoopCount",()=>this._undirectedSelfLoopCount),D(this,"multi",this._options.multi),D(this,"type",this._options.type),D(this,"allowSelfLoops",this._options.allowSelfLoops),D(this,"implementation",()=>"graphology")}_resetInstanceCounters(){this._directedSize=0,this._undirectedSize=0,this._directedSelfLoopCount=0,this._undirectedSelfLoopCount=0}hasNode(t){return this._nodes.has(""+t)}hasDirectedEdge(t,e){if(this.type==="undirected")return!1;if(arguments.length===1){const i=""+t,n=this._edges.get(i);return!!n&&!n.undirected}else if(arguments.length===2){t=""+t,e=""+e;const i=this._nodes.get(t);return i?i.out.hasOwnProperty(e):!1}throw new l(`Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`)}hasUndirectedEdge(t,e){if(this.type==="directed")return!1;if(arguments.length===1){const i=""+t,n=this._edges.get(i);return!!n&&n.undirected}else if(arguments.length===2){t=""+t,e=""+e;const i=this._nodes.get(t);return i?i.undirected.hasOwnProperty(e):!1}throw new l(`Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`)}hasEdge(t,e){if(arguments.length===1){const i=""+t;return this._edges.has(i)}else if(arguments.length===2){t=""+t,e=""+e;const i=this._nodes.get(t);return i?typeof i.out<"u"&&i.out.hasOwnProperty(e)||typeof i.undirected<"u"&&i.undirected.hasOwnProperty(e):!1}throw new l(`Graph.hasEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`)}directedEdge(t,e){if(this.type==="undirected")return;if(t=""+t,e=""+e,this.multi)throw new g("Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.");const i=this._nodes.get(t);if(!i)throw new f(`Graph.directedEdge: could not find the "${t}" source node in the graph.`);if(!this._nodes.has(e))throw new f(`Graph.directedEdge: could not find the "${e}" target node in the graph.`);const n=i.out&&i.out[e]||void 0;if(n)return n.key}undirectedEdge(t,e){if(this.type==="directed")return;if(t=""+t,e=""+e,this.multi)throw new g("Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.");const i=this._nodes.get(t);if(!i)throw new f(`Graph.undirectedEdge: could not find the "${t}" source node in the graph.`);if(!this._nodes.has(e))throw new f(`Graph.undirectedEdge: could not find the "${e}" target node in the graph.`);const n=i.undirected&&i.undirected[e]||void 0;if(n)return n.key}edge(t,e){if(this.multi)throw new g("Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.");t=""+t,e=""+e;const i=this._nodes.get(t);if(!i)throw new f(`Graph.edge: could not find the "${t}" source node in the graph.`);if(!this._nodes.has(e))throw new f(`Graph.edge: could not find the "${e}" target node in the graph.`);const n=i.out&&i.out[e]||i.undirected&&i.undirected[e]||void 0;if(n)return n.key}areDirectedNeighbors(t,e){t=""+t,e=""+e;const i=this._nodes.get(t);if(!i)throw new f(`Graph.areDirectedNeighbors: could not find the "${t}" node in the graph.`);return this.type==="undirected"?!1:e in i.in||e in i.out}areOutNeighbors(t,e){t=""+t,e=""+e;const i=this._nodes.get(t);if(!i)throw new f(`Graph.areOutNeighbors: could not find the "${t}" node in the graph.`);return this.type==="undirected"?!1:e in i.out}areInNeighbors(t,e){t=""+t,e=""+e;const i=this._nodes.get(t);if(!i)throw new f(`Graph.areInNeighbors: could not find the "${t}" node in the graph.`);return this.type==="undirected"?!1:e in i.in}areUndirectedNeighbors(t,e){t=""+t,e=""+e;const i=this._nodes.get(t);if(!i)throw new f(`Graph.areUndirectedNeighbors: could not find the "${t}" node in the graph.`);return this.type==="directed"?!1:e in i.undirected}areNeighbors(t,e){t=""+t,e=""+e;const i=this._nodes.get(t);if(!i)throw new f(`Graph.areNeighbors: could not find the "${t}" node in the graph.`);return this.type!=="undirected"&&(e in i.in||e in i.out)||this.type!=="directed"&&e in i.undirected}areInboundNeighbors(t,e){t=""+t,e=""+e;const i=this._nodes.get(t);if(!i)throw new f(`Graph.areInboundNeighbors: could not find the "${t}" node in the graph.`);return this.type!=="undirected"&&e in i.in||this.type!=="directed"&&e in i.undirected}areOutboundNeighbors(t,e){t=""+t,e=""+e;const i=this._nodes.get(t);if(!i)throw new f(`Graph.areOutboundNeighbors: could not find the "${t}" node in the graph.`);return this.type!=="undirected"&&e in i.out||this.type!=="directed"&&e in i.undirected}inDegree(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new f(`Graph.inDegree: could not find the "${t}" node in the graph.`);return this.type==="undirected"?0:e.inDegree}outDegree(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new f(`Graph.outDegree: could not find the "${t}" node in the graph.`);return this.type==="undirected"?0:e.outDegree}directedDegree(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new f(`Graph.directedDegree: could not find the "${t}" node in the graph.`);return this.type==="undirected"?0:e.inDegree+e.outDegree}undirectedDegree(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new f(`Graph.undirectedDegree: could not find the "${t}" node in the graph.`);return this.type==="directed"?0:e.undirectedDegree}inboundDegree(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new f(`Graph.inboundDegree: could not find the "${t}" node in the graph.`);let i=0;return this.type!=="directed"&&(i+=e.undirectedDegree),this.type!=="undirected"&&(i+=e.inDegree),i}outboundDegree(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new f(`Graph.outboundDegree: could not find the "${t}" node in the graph.`);let i=0;return this.type!=="directed"&&(i+=e.undirectedDegree),this.type!=="undirected"&&(i+=e.outDegree),i}degree(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new f(`Graph.degree: could not find the "${t}" node in the graph.`);let i=0;return this.type!=="directed"&&(i+=e.undirectedDegree),this.type!=="undirected"&&(i+=e.inDegree+e.outDegree),i}inDegreeWithoutSelfLoops(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new f(`Graph.inDegreeWithoutSelfLoops: could not find the "${t}" node in the graph.`);return this.type==="undirected"?0:e.inDegree-e.directedLoops}outDegreeWithoutSelfLoops(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new f(`Graph.outDegreeWithoutSelfLoops: could not find the "${t}" node in the graph.`);return this.type==="undirected"?0:e.outDegree-e.directedLoops}directedDegreeWithoutSelfLoops(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new f(`Graph.directedDegreeWithoutSelfLoops: could not find the "${t}" node in the graph.`);return this.type==="undirected"?0:e.inDegree+e.outDegree-e.directedLoops*2}undirectedDegreeWithoutSelfLoops(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new f(`Graph.undirectedDegreeWithoutSelfLoops: could not find the "${t}" node in the graph.`);return this.type==="directed"?0:e.undirectedDegree-e.undirectedLoops*2}inboundDegreeWithoutSelfLoops(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new f(`Graph.inboundDegreeWithoutSelfLoops: could not find the "${t}" node in the graph.`);let i=0,n=0;return this.type!=="directed"&&(i+=e.undirectedDegree,n+=e.undirectedLoops*2),this.type!=="undirected"&&(i+=e.inDegree,n+=e.directedLoops),i-n}outboundDegreeWithoutSelfLoops(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new f(`Graph.outboundDegreeWithoutSelfLoops: could not find the "${t}" node in the graph.`);let i=0,n=0;return this.type!=="directed"&&(i+=e.undirectedDegree,n+=e.undirectedLoops*2),this.type!=="undirected"&&(i+=e.outDegree,n+=e.directedLoops),i-n}degreeWithoutSelfLoops(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new f(`Graph.degreeWithoutSelfLoops: could not find the "${t}" node in the graph.`);let i=0,n=0;return this.type!=="directed"&&(i+=e.undirectedDegree,n+=e.undirectedLoops*2),this.type!=="undirected"&&(i+=e.inDegree+e.outDegree,n+=e.directedLoops*2),i-n}source(t){t=""+t;const e=this._edges.get(t);if(!e)throw new f(`Graph.source: could not find the "${t}" edge in the graph.`);return e.source.key}target(t){t=""+t;const e=this._edges.get(t);if(!e)throw new f(`Graph.target: could not find the "${t}" edge in the graph.`);return e.target.key}extremities(t){t=""+t;const e=this._edges.get(t);if(!e)throw new f(`Graph.extremities: could not find the "${t}" edge in the graph.`);return[e.source.key,e.target.key]}opposite(t,e){t=""+t,e=""+e;const i=this._edges.get(e);if(!i)throw new f(`Graph.opposite: could not find the "${e}" edge in the graph.`);const n=i.source.key,o=i.target.key;if(t===n)return o;if(t===o)return n;throw new f(`Graph.opposite: the "${t}" node is not attached to the "${e}" edge (${n}, ${o}).`)}hasExtremity(t,e){t=""+t,e=""+e;const i=this._edges.get(t);if(!i)throw new f(`Graph.hasExtremity: could not find the "${t}" edge in the graph.`);return i.source.key===e||i.target.key===e}isUndirected(t){t=""+t;const e=this._edges.get(t);if(!e)throw new f(`Graph.isUndirected: could not find the "${t}" edge in the graph.`);return e.undirected}isDirected(t){t=""+t;const e=this._edges.get(t);if(!e)throw new f(`Graph.isDirected: could not find the "${t}" edge in the graph.`);return!e.undirected}isSelfLoop(t){t=""+t;const e=this._edges.get(t);if(!e)throw new f(`Graph.isSelfLoop: could not find the "${t}" edge in the graph.`);return e.source===e.target}addNode(t,e){return pe(this,t,e).key}mergeNode(t,e){if(e&&!$(e))throw new l(`Graph.mergeNode: invalid attributes. Expecting an object but got "${e}"`);t=""+t,e=e||{};let i=this._nodes.get(t);return i?(e&&(b(i.attributes,e),this.emit("nodeAttributesUpdated",{type:"merge",key:t,attributes:i.attributes,data:e})),[t,!1]):(i=new this.NodeDataClass(t,e),this._nodes.set(t,i),this.emit("nodeAdded",{key:t,attributes:e}),[t,!0])}updateNode(t,e){if(e&&typeof e!="function")throw new l(`Graph.updateNode: invalid updater function. Expecting a function but got "${e}"`);t=""+t;let i=this._nodes.get(t);if(i){if(e){const o=i.attributes;i.attributes=e(o),this.emit("nodeAttributesUpdated",{type:"replace",key:t,attributes:i.attributes})}return[t,!1]}const n=e?e({}):{};return i=new this.NodeDataClass(t,n),this._nodes.set(t,i),this.emit("nodeAdded",{key:t,attributes:n}),[t,!0]}dropNode(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new f(`Graph.dropNode: could not find the "${t}" node in the graph.`);let i;if(this.type!=="undirected"){for(const n in e.out){i=e.out[n];do S(this,i),i=i.next;while(i)}for(const n in e.in){i=e.in[n];do S(this,i),i=i.next;while(i)}}if(this.type!=="directed")for(const n in e.undirected){i=e.undirected[n];do S(this,i),i=i.next;while(i)}this._nodes.delete(t),this.emit("nodeDropped",{key:t,attributes:e.attributes})}dropEdge(t){let e;if(arguments.length>1){const i=""+arguments[0],n=""+arguments[1];if(e=x(this,i,n,this.type),!e)throw new f(`Graph.dropEdge: could not find the "${i}" -> "${n}" edge in the graph.`)}else if(t=""+t,e=this._edges.get(t),!e)throw new f(`Graph.dropEdge: could not find the "${t}" edge in the graph.`);return S(this,e),this}dropDirectedEdge(t,e){if(arguments.length<2)throw new g("Graph.dropDirectedEdge: it does not make sense to try and drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");if(this.multi)throw new g("Graph.dropDirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");t=""+t,e=""+e;const i=x(this,t,e,"directed");if(!i)throw new f(`Graph.dropDirectedEdge: could not find a "${t}" -> "${e}" edge in the graph.`);return S(this,i),this}dropUndirectedEdge(t,e){if(arguments.length<2)throw new g("Graph.dropUndirectedEdge: it does not make sense to drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");if(this.multi)throw new g("Graph.dropUndirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");const i=x(this,t,e,"undirected");if(!i)throw new f(`Graph.dropUndirectedEdge: could not find a "${t}" -> "${e}" edge in the graph.`);return S(this,i),this}clear(){this._edges.clear(),this._nodes.clear(),this._resetInstanceCounters(),this.emit("cleared")}clearEdges(){const t=this._nodes.values();let e;for(;e=t.next(),e.done!==!0;)e.value.clear();this._edges.clear(),this._resetInstanceCounters(),this.emit("edgesCleared")}getAttribute(t){return this._attributes[t]}getAttributes(){return this._attributes}hasAttribute(t){return this._attributes.hasOwnProperty(t)}setAttribute(t,e){return this._attributes[t]=e,this.emit("attributesUpdated",{type:"set",attributes:this._attributes,name:t}),this}updateAttribute(t,e){if(typeof e!="function")throw new l("Graph.updateAttribute: updater should be a function.");const i=this._attributes[t];return this._attributes[t]=e(i),this.emit("attributesUpdated",{type:"set",attributes:this._attributes,name:t}),this}removeAttribute(t){return delete this._attributes[t],this.emit("attributesUpdated",{type:"remove",attributes:this._attributes,name:t}),this}replaceAttributes(t){if(!$(t))throw new l("Graph.replaceAttributes: provided attributes are not a plain object.");return this._attributes=t,this.emit("attributesUpdated",{type:"replace",attributes:this._attributes}),this}mergeAttributes(t){if(!$(t))throw new l("Graph.mergeAttributes: provided attributes are not a plain object.");return b(this._attributes,t),this.emit("attributesUpdated",{type:"merge",attributes:this._attributes,data:t}),this}updateAttributes(t){if(typeof t!="function")throw new l("Graph.updateAttributes: provided updater is not a function.");return this._attributes=t(this._attributes),this.emit("attributesUpdated",{type:"update",attributes:this._attributes}),this}updateEachNodeAttributes(t,e){if(typeof t!="function")throw new l("Graph.updateEachNodeAttributes: expecting an updater function.");if(e&&!R(e))throw new l("Graph.updateEachNodeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");const i=this._nodes.values();let n,o;for(;n=i.next(),n.done!==!0;)o=n.value,o.attributes=t(o.key,o.attributes);this.emit("eachNodeAttributesUpdated",{hints:e||null})}updateEachEdgeAttributes(t,e){if(typeof t!="function")throw new l("Graph.updateEachEdgeAttributes: expecting an updater function.");if(e&&!R(e))throw new l("Graph.updateEachEdgeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");const i=this._edges.values();let n,o,s,a;for(;n=i.next(),n.done!==!0;)o=n.value,s=o.source,a=o.target,o.attributes=t(o.key,o.attributes,s.key,a.key,s.attributes,a.attributes,o.undirected);this.emit("eachEdgeAttributesUpdated",{hints:e||null})}forEachAdjacencyEntry(t){if(typeof t!="function")throw new l("Graph.forEachAdjacencyEntry: expecting a callback.");j(!1,!1,!1,this,t)}forEachAdjacencyEntryWithOrphans(t){if(typeof t!="function")throw new l("Graph.forEachAdjacencyEntryWithOrphans: expecting a callback.");j(!1,!1,!0,this,t)}forEachAssymetricAdjacencyEntry(t){if(typeof t!="function")throw new l("Graph.forEachAssymetricAdjacencyEntry: expecting a callback.");j(!1,!0,!1,this,t)}forEachAssymetricAdjacencyEntryWithOrphans(t){if(typeof t!="function")throw new l("Graph.forEachAssymetricAdjacencyEntryWithOrphans: expecting a callback.");j(!1,!0,!0,this,t)}nodes(){return Array.from(this._nodes.keys())}forEachNode(t){if(typeof t!="function")throw new l("Graph.forEachNode: expecting a callback.");const e=this._nodes.values();let i,n;for(;i=e.next(),i.done!==!0;)n=i.value,t(n.key,n.attributes)}findNode(t){if(typeof t!="function")throw new l("Graph.findNode: expecting a callback.");const e=this._nodes.values();let i,n;for(;i=e.next(),i.done!==!0;)if(n=i.value,t(n.key,n.attributes))return n.key}mapNodes(t){if(typeof t!="function")throw new l("Graph.mapNode: expecting a callback.");const e=this._nodes.values();let i,n;const o=new Array(this.order);let s=0;for(;i=e.next(),i.done!==!0;)n=i.value,o[s++]=t(n.key,n.attributes);return o}someNode(t){if(typeof t!="function")throw new l("Graph.someNode: expecting a callback.");const e=this._nodes.values();let i,n;for(;i=e.next(),i.done!==!0;)if(n=i.value,t(n.key,n.attributes))return!0;return!1}everyNode(t){if(typeof t!="function")throw new l("Graph.everyNode: expecting a callback.");const e=this._nodes.values();let i,n;for(;i=e.next(),i.done!==!0;)if(n=i.value,!t(n.key,n.attributes))return!1;return!0}filterNodes(t){if(typeof t!="function")throw new l("Graph.filterNodes: expecting a callback.");const e=this._nodes.values();let i,n;const o=[];for(;i=e.next(),i.done!==!0;)n=i.value,t(n.key,n.attributes)&&o.push(n.key);return o}reduceNodes(t,e){if(typeof t!="function")throw new l("Graph.reduceNodes: expecting a callback.");if(arguments.length<2)throw new l("Graph.reduceNodes: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.");let i=e;const n=this._nodes.values();let o,s;for(;o=n.next(),o.done!==!0;)s=o.value,i=t(i,s.key,s.attributes);return i}nodeEntries(){const t=this._nodes.values();return{[Symbol.iterator](){return this},next(){const e=t.next();if(e.done)return e;const i=e.value;return{value:{node:i.key,attributes:i.attributes},done:!1}}}}export(){const t=new Array(this._nodes.size);let e=0;this._nodes.forEach((n,o)=>{t[e++]=oe(o,n)});const i=new Array(this._edges.size);return e=0,this._edges.forEach((n,o)=>{i[e++]=se(this.type,o,n)}),{options:{type:this.type,multi:this.multi,allowSelfLoops:this.allowSelfLoops},attributes:this.getAttributes(),nodes:t,edges:i}}import(t,e=!1){if(t instanceof w)return t.forEachNode((d,u)=>{e?this.mergeNode(d,u):this.addNode(d,u)}),t.forEachEdge((d,u,c,h,p,y,m)=>{e?m?this.mergeUndirectedEdgeWithKey(d,c,h,u):this.mergeDirectedEdgeWithKey(d,c,h,u):m?this.addUndirectedEdgeWithKey(d,c,h,u):this.addDirectedEdgeWithKey(d,c,h,u)}),this;if(!$(t))throw new l("Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.");if(t.attributes){if(!$(t.attributes))throw new l("Graph.import: invalid attributes. Expecting a plain object.");e?this.mergeAttributes(t.attributes):this.replaceAttributes(t.attributes)}let i,n,o,s,a;if(t.nodes){if(o=t.nodes,!Array.isArray(o))throw new l("Graph.import: invalid nodes. Expecting an array.");for(i=0,n=o.length;i<n;i++){s=o[i],ae(s);const{key:d,attributes:u}=s;e?this.mergeNode(d,u):this.addNode(d,u)}}if(t.edges){let d=!1;if(this.type==="undirected"&&(d=!0),o=t.edges,!Array.isArray(o))throw new l("Graph.import: invalid edges. Expecting an array.");for(i=0,n=o.length;i<n;i++){a=o[i],ue(a);const{source:u,target:c,attributes:h,undirected:p=d}=a;let y;"key"in a?(y=e?p?this.mergeUndirectedEdgeWithKey:this.mergeDirectedEdgeWithKey:p?this.addUndirectedEdgeWithKey:this.addDirectedEdgeWithKey,y.call(this,a.key,u,c,h)):(y=e?p?this.mergeUndirectedEdge:this.mergeDirectedEdge:p?this.addUndirectedEdge:this.addDirectedEdge,y.call(this,u,c,h))}}return this}nullCopy(t){const e=new w(b({},this._options,t));return e.replaceAttributes(b({},this.getAttributes())),e}emptyCopy(t){const e=this.nullCopy(t);return this._nodes.forEach((i,n)=>{const o=b({},i.attributes);i=new e.NodeDataClass(n,o),e._nodes.set(n,i)}),e}copy(t){if(t=t||{},typeof t.type=="string"&&t.type!==this.type&&t.type!=="mixed")throw new g(`Graph.copy: cannot create an incompatible copy from "${this.type}" type to "${t.type}" because this would mean losing information about the current graph.`);if(typeof t.multi=="boolean"&&t.multi!==this.multi&&t.multi!==!0)throw new g("Graph.copy: cannot create an incompatible copy by downgrading a multi graph to a simple one because this would mean losing information about the current graph.");if(typeof t.allowSelfLoops=="boolean"&&t.allowSelfLoops!==this.allowSelfLoops&&t.allowSelfLoops!==!0)throw new g("Graph.copy: cannot create an incompatible copy from a graph allowing self loops to one that does not because this would mean losing information about the current graph.");const e=this.emptyCopy(t),i=this._edges.values();let n,o;for(;n=i.next(),n.done!==!0;)o=n.value,it(e,"copy",!1,o.undirected,o.key,o.source.key,o.target.key,b({},o.attributes));return e}toJSON(){return this.export()}toString(){return"[object Graph]"}inspect(){const t={};this._nodes.forEach((o,s)=>{t[s]=o.attributes});const e={},i={};this._edges.forEach((o,s)=>{const a=o.undirected?"--":"->";let d="",u=o.source.key,c=o.target.key,h;o.undirected&&u>c&&(h=u,u=c,c=h);const p=`(${u})${a}(${c})`;s.startsWith("geid_")?this.multi&&(typeof i[p]>"u"?i[p]=0:i[p]++,d+=`${i[p]}. `):d+=`[${s}]: `,d+=p,e[d]=o.attributes});const n={};for(const o in this)this.hasOwnProperty(o)&&!Y.has(o)&&typeof this[o]!="function"&&typeof o!="symbol"&&(n[o]=this[o]);return n.attributes=this._attributes,n.nodes=t,n.edges=e,_(n,"constructor",this.constructor),n}}typeof Symbol<"u"&&(w.prototype[Symbol.for("nodejs.util.inspect.custom")]=w.prototype.inspect);ce.forEach(r=>{["add","merge","update"].forEach(t=>{const e=r.name(t),i=t==="add"?it:le;r.generateKey?w.prototype[e]=function(n,o,s){return i(this,e,!0,(r.type||this.type)==="undirected",null,n,o,s,t==="update")}:w.prototype[e]=function(n,o,s,a){return i(this,e,!1,(r.type||this.type)==="undirected",n,o,s,a,t==="update")}})});kt(w);Ct(w);qt(w);re(w);class nt extends w{constructor(t){const e=b({type:"directed"},t);if("multi"in e&&e.multi!==!1)throw new l("DirectedGraph.from: inconsistent indication that the graph should be multi in given options!");if(e.type!=="directed")throw new l('DirectedGraph.from: inconsistent "'+e.type+'" type in given options!');super(e)}}class rt extends w{constructor(t){const e=b({type:"undirected"},t);if("multi"in e&&e.multi!==!1)throw new l("UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!");if(e.type!=="undirected")throw new l('UndirectedGraph.from: inconsistent "'+e.type+'" type in given options!');super(e)}}class ot extends w{constructor(t){const e=b({multi:!0},t);if("multi"in e&&e.multi!==!0)throw new l("MultiGraph.from: inconsistent indication that the graph should be simple in given options!");super(e)}}class st extends w{constructor(t){const e=b({type:"directed",multi:!0},t);if("multi"in e&&e.multi!==!0)throw new l("MultiDirectedGraph.from: inconsistent indication that the graph should be simple in given options!");if(e.type!=="directed")throw new l('MultiDirectedGraph.from: inconsistent "'+e.type+'" type in given options!');super(e)}}class at extends w{constructor(t){const e=b({type:"undirected",multi:!0},t);if("multi"in e&&e.multi!==!0)throw new l("MultiUndirectedGraph.from: inconsistent indication that the graph should be simple in given options!");if(e.type!=="undirected")throw new l('MultiUndirectedGraph.from: inconsistent "'+e.type+'" type in given options!');super(e)}}function M(r){r.from=function(t,e){const i=b({},t.options,e),n=new r(i);return n.import(t),n}}M(w);M(nt);M(rt);M(ot);M(st);M(at);w.Graph=w;w.DirectedGraph=nt;w.UndirectedGraph=rt;w.MultiGraph=ot;w.MultiDirectedGraph=st;w.MultiUndirectedGraph=at;w.InvalidArgumentsGraphError=l;w.NotFoundGraphError=f;w.UsageGraphError=g;export{nt as DirectedGraph,w as Graph,l as InvalidArgumentsGraphError,st as MultiDirectedGraph,ot as MultiGraph,at as MultiUndirectedGraph,f as NotFoundGraphError,rt as UndirectedGraph,g as UsageGraphError,w as default};
